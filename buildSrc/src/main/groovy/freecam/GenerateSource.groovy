package freecam

import com.squareup.javapoet.*
import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import org.slf4j.Logger
import org.slf4j.LoggerFactory

import javax.annotation.processing.Generated
import javax.lang.model.element.Modifier
import java.lang.reflect.Type
import java.time.ZonedDateTime

import static java.time.ZoneOffset.UTC
import static java.time.format.DateTimeFormatter.ISO_INSTANT

/**
 * A task that generates a source file and writes the result to an output directory
 */
abstract class GenerateSource extends DefaultTask {

    private static final Logger LOG = LoggerFactory.getLogger(GenerateSource)

    @OutputDirectory
    abstract DirectoryProperty getOutputDir()

    @Input
    @Optional
    abstract Property<String> getPackageName()

    @Input
    abstract Property<String> getClassName()

    @Input
    @Optional
    abstract Property<Boolean> getFormatFieldNames()

    @Input
    @Optional
    abstract MapProperty<String, Object> getData()

    @TaskAction
    def build() {
        String packageName = packageName.getOrElse(project.group.toString())
        String className = className.get()
        File dir = outputDir.get().asFile
        LOG.debug "Generating class ${className}"

        AnnotationSpec generatedAnnotation = AnnotationSpec.builder(Generated.class)
                .addMember("value", '$S', "Gradle build script (${path})")
                .addMember("date", '$S', ZonedDateTime.now(UTC).format(ISO_INSTANT))
                .build()

        MethodSpec init = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PRIVATE)
                .addComment("No instances")
                .build()

        TypeSpec typeSpec = TypeSpec.classBuilder(className)
                .addAnnotation(generatedAnnotation)
                .addJavadoc("This file was generated by the gradle build script. DO NOT EDIT.")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addMethod(init)
                .addFields(buildFieldSpecs())
                .build();

        JavaFile javaFile = JavaFile.builder(packageName, typeSpec)
                .build();

        LOG.info "Writing generated class ${className} to ${dir.absolutePath}"
        if (!dir.exists()) {
            dir.mkdirs()
        }
        javaFile.writeTo(dir)
    }

    private List buildFieldSpecs() {
        data.getOrElse(Collections.emptyMap()).entrySet().stream()
        .map { entry ->
            String name = formatFieldNames.getOrElse(true)
                    ? GenerateSource.formatFieldName(entry.key)
                    : entry.key
            Object value = entry.value
            Type type = GenerateSource.primitiveType(value)
            String fmt = type == String.class ? '$S' : '$L'

            return FieldSpec.builder(type, name, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                    .initializer(fmt, value)
                    .build()
        }
        .toList()
    }

    /**
     * Format the given name as upper snake case
     */
    private static String formatFieldName(String name) {
        // First, check for camel case (before mutating case info)
        List<String> parts = new ArrayList<>()
        int lastSplit = 0
        name.chars().eachWithIndex { int c, int i ->
            // Don't split if previous char is uppercase
            if (i == 0 || Character.isUpperCase(name.charAt(i-1))) {
                return
            }

            if (Character.isUpperCase(c)) {
                parts.add(name.substring(lastSplit, i))
                lastSplit = i
            }
        }
        parts.add(name.substring(lastSplit))

        return parts.join('_').replaceAll('-', '_').toUpperCase()
    }

    /**
     * Get value's type, unboxing to a primitive if possible.
     *
     * @return value's unboxed type
     */
    private static Type primitiveType(Object value) {
        // Shouldn't be possible, but check anyway:
        if (value.class.isPrimitive()) {
            return value.class
        }
        if (value instanceof Number) {
            if (value instanceof Integer) {
                return int.class
            }
            if (value instanceof Short) {
                return short.class
            }
            if (value instanceof Float) {
                return float.class
            }
            if (value instanceof Double) {
                return double.class
            }
        }
        if (value instanceof Boolean) {
            return boolean.class
        }
        if (value instanceof Byte) {
            return byte.class
        }
        if (value instanceof Character) {
            return char.class
        }
        return value.getClass()
    }
}
